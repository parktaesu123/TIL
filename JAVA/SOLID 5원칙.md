<aside>
🚀 **SOLID 5가지 원칙이란?**

</aside>

- **좋은 객체 지향 설계를 위한 5가지 원칙이다**
- 종류로는 `SRP-단일 책임 원칙`, `OCP-개방 폐쇄 원칙`, `LSP-리스코프 치환 원칙`, `ISP-인터페이스 분리 원칙`, `DIP 의존 역전 원칙이 있다.`

## 단일 책임 원칙-(SRP)

---

- ***하나의 클래스 , 메서드는 하나의 책임만 가져야 한다.***
- 클래스를 변경한다면 그 이유는 **단 하나** 여야 한다.
    - 변경이 있을 때 파급효과가 적어야 한다.
    - 이를 지키지 않을 경우, 한 변경 코드로 인해 다른 관련된 코드들이 영향을 끼칠 수 있다.

<aside>
❗ **객체 지향 설계의 핵심은 높은 응집도와 낮은 결합도**

</aside>

## 개방 폐쇄 원칙-(OCP)

---

- ***자신의 확장에는 개방돼 있고, 주변의 변화에 대해서는 폐쇄돼 있어야 한다.***
- 기존의 코드를 변경하지 않고 기능을 수정, 추가할 수 있도록 설계해야 한다.
    - **인터페이스를 구현한 새로운 클래스**를 하나 만들어서 새로운 기능을 구현한다.

<aside>
❓ **기존의 코드를 변경하지 않고 어떻게 기능을 수정, 추가할 수 있을까?**

</aside>

- **상속(다형성), 추상화(인터페이스)**를 활용하면 된다. 자주 변경하는 부분을 추상화 해서 기존 코드를 수정하지 않고 기능을 확장할 수 있도록 해서 유연성을 살릴 수 있다.

## 리스코프 치환 원칙-(LSP)

---

- ***서브타입은 언제나 자신의 상위 타입으로 교체할 수 있어야 한다.***
- `하위 타입 객체`는 `상위 타입 객체`에서 가능한 행위를 수행할 수 있어야 한다.
    - 즉, `상위 타입 객체`를 `하위 타입 객체`로 대체하여도 정상적으로 동작해야 한다.

<aside>
💡 **LSP를 위반하면 OCP 또한 위반한다**.

</aside>

- 따라서 **상속 관계**를 잘 정의하여 LSP가 위반되지 않도록 설계해야 한다.

## 인터페이스 분리 원칙-(ISP)

---

- ***클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.***
- 클라이언트는 자신이 사용하는 메소드에만 의존해야 한다.
    - **특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 한 개보다 낫다.**
    - 인터페이스는 해당 인터페이스를 사용하는 클라이언트를 기준으로 잘게 분리되어야 한다.

<aside>
🤝 **각 클라이언트가 필요로 하는 인터페이스를 분리해서 클라이언트가 사용하지 않는 인터페이스에 변경이 발생해도 다를 인터페이스는 영향을 받지 않도록 만드는 것이 ISP의 핵심이다.**

</aside>

## 의존 역전 원칙-(DIP)

---

- ***프로그래머는 추상회에 의존해야지, 구체화에 의존하면 안된다.***
- **의존 관계**를 맺을 때, 변하기 쉬운 구체적인 것 보다는 변하기 어려운 추상적인 것에 의존해야 한다는 것이다.
    - **즉, 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다.**
- DIP를 구현하는 한가지 방법이 **DI(Dependency Injection)**이다.

<aside>
🚀 **고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다**

</aside>

- **저수준 모듈**이 변경되어도 **고수준 모듈**은 변경이 필요없는 형태가 이상적이다.

### 참고자료

[https://velog.io/@pp8817/SOLID-좋은-객체지향-설계의-5가지-원칙](https://velog.io/@pp8817/SOLID-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99)

https://sehun-kim.github.io/sehun/solid/
